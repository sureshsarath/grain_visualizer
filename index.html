<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>GRAIN Visualizer</title>

    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

    <!-- MapLibre CSS -->
    <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link href="css/style.css" rel="stylesheet" />
</head>

<body>
    <!-- 1. Header -->
    <header>
        <div class="header-title"><span class="brand-strong">GRAIN</span> <span class="brand-muted">Visualizer</span></div>
        <nav class="header-nav">
            <a class="header-doc-link" href="https://grain-canals.readthedocs.io/en/latest/" target="_blank" rel="noopener">Documentation</a>
            <a href="disclaimer.html" target="_blank" rel="noopener">Disclaimer</a>
        </nav>
    </header>

    <!-- 2. Sidebar -->
    <aside>
        <div class="logo-placeholder">
            <img src="assets/grain_logo.png" alt="GRAIN logo" />
        </div>

        <div class="panel-section">
            <div class="panel-title">Region Selection</div>
            <select class="grain-input" id="country-select">
                <option value="global">Global View</option>
                <option disabled>──────────</option>
                <option value="IN">India</option>
                <option value="CN">China</option>
                <option value="US">United States</option>
                <!-- More options will be populated dynamically -->
            </select>
        </div>

        <div class="panel-section">
            <div class="panel-title">Stats</div>
            <div class="stat-grid">
                <!-- Box 1: Length -->
                <div class="stat-box blue">
                    <span class="stat-label">Total Length</span>
                    <div>
                        <span class="stat-value" id="stat-length">3.82</span>
                        <span class="stat-unit" id="stat-length-unit">million km</span>
                    </div>
                </div>
                <!-- Box 2: Cropland Area -->
                <div class="stat-box amber">
                    <span class="stat-label">Cropland Area</span>
                    <div>
                        <span class="stat-value" id="stat-cropland">39.48</span>
                        <span class="stat-unit" id="stat-cropland-unit">million km<sup>2</sup></span>
                    </div>
                </div>
                <!-- Box 3: Density -->
                <div class="stat-box green" style="grid-column: span 2;">
                    <span class="stat-label">Canal Density</span>
                    <div>
                        <span class="stat-value" id="stat-density">200.1</span>
                        <span class="stat-unit" id="stat-density-unit">km/1000km<sup>2</sup> of cropland</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="panel-section">
            <div class="panel-title">Download Data</div>
            <a class="download-button" href="https://doi.org/10.5281/zenodo.16786488" target="_blank" rel="noopener">
                Download Full Dataset
            </a>
        </div>
    </aside>

    <!-- 3. Map Area -->
    <main id="map">
        <div class="map-control-card">
            <span>Basemap</span>
            <select id="basemap-select">
                <option value="standard" selected>Standard</option>
                <option value="satellite">Satellite</option>
                <option value="night">Night</option>
            </select>
        </div>
        <div class="map-control-card map-toggle-card">
            <label class="canal-toggle">
                <span class="canal-toggle-text">Toggle canals</span>
                <input type="checkbox" id="canals-toggle" class="canal-switch-input" checked />
                <span class="canal-switch" aria-hidden="true"></span>
            </label>
        </div>
        <div class="map-logo">
            <a href="https://saswe.net" target="_blank" rel="noopener">
                <img class="logo-saswe" src="assets/saswe_logo.png" alt="SASWE logo" />
            </a>
            <img class="logo-uw" src="assets/uw_logo.png" alt="University of Washington logo" />
        </div>
    </main>

    <!-- 4. Footer -->
    <footer>
        <div class="footer-logos">
            <span class="footer-logo-text footer-logo-uw">
                <span class="footer-logo-sub">Maintained by </span>
                <span class="footer-strong">Sarath Suresh</span>
                <span class="footer-logo-sub">, University of Washington</span>
            </span>
        </div>
        <div class="footer-logos">
            <span class="footer-logo-text footer-logo-sub">Department of Civil and Environmental Engineering</span>
        </div>
    </footer>

    <!-- MapLibre JS -->
    <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>

    <!-- PMTiles UMD build (IMPORTANT) -->
    <script src="https://unpkg.com/pmtiles@3.2.0/dist/pmtiles.js"></script>

    <script>
        // 1️⃣ Register PMTiles protocol BEFORE creating map
        const protocol = new pmtiles.Protocol();
        maplibregl.addProtocol("pmtiles", protocol.tile);

        console.log("pmtiles global:", pmtiles);

        // 2️⃣ PMTiles URL (long path, as requested)
        const PMTILES_URL =
            "https://pub-9a261f2211db4953b44c3cb6016ab4e8.r2.dev/pmtiles/v1.0/grain_global_v1_0.pmtiles";

        // 3️⃣ Create map with simple OSM basemap
        const map = new maplibregl.Map({
            container: "map",
            style: {
                version: 8,
                sources: {
                    osm: {
                        type: "raster",
                        tiles: ["https://services.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}"],
                        tileSize: 256,
                        attribution: "© Esri"
                    },
                    esri_imagery: {
                        type: "raster",
                        tiles: ["https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}"],
                        tileSize: 256,
                        attribution: "© Esri"
                    },
                    carto_dark: {
                        type: "raster",
                        tiles: [
                            "https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png",
                            "https://b.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png",
                            "https://c.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png"
                        ],
                        tileSize: 256,
                        attribution: "© OpenStreetMap contributors © CARTO"
                    }
                },
                layers: [
                    { id: "osm", type: "raster", source: "osm" },
                    { id: "esri-imagery", type: "raster", source: "esri_imagery", layout: { visibility: "none" } },
                    { id: "carto-dark", type: "raster", source: "carto_dark", layout: { visibility: "none" } }
                ]
            },
            center: [0, 20],
            zoom: 1
        });

        map.addControl(new maplibregl.NavigationControl(), "top-right");
        const popup = new maplibregl.Popup({ closeButton: true, closeOnClick: true });
        const baseLineWidthExpr = [
            "interpolate", ["linear"], ["zoom"],
            2, 1,
            5, 1.0,
            8, 1.2,
            12, 2.3
        ];

        // 4️⃣ Add PMTiles vector source + layer
        map.on("load", () => {
            map.addSource("grain", {
                type: "vector",
                url: `pmtiles://${PMTILES_URL}`
            });

            // ⚠️ This must match the PMTiles internal layer name
            // We will fix this once you paste `pmtiles info` output
            const sourceLayer = "grain_canals";

            map.addLayer({
                id: "grain-lines",
                type: "line",
                source: "grain",
                "source-layer": sourceLayer,
                paint: {
                    "line-color": "blue", /* Tailwind blue-600 */
                    "line-opacity": 0.9,
                    "line-width": baseLineWidthExpr
                }
            });

            setCanalsVisibility();

            map.on("mouseenter", "grain-lines", () => {
                map.getCanvas().style.cursor = "pointer";
            });

            map.on("mouseleave", "grain-lines", () => {
                map.getCanvas().style.cursor = "";
            });

            map.on("click", "grain-lines", (e) => {
                const feature = e.features?.[0];
                if (!feature?.properties) {
                    return;
                }

                const rows = Object.entries(feature.properties)
                    .map(([key, value]) => {
                        const safeKey = String(key).replace(/_/g, " ");
                        const safeValue = value === null || value === undefined ? "—" : String(value);
                        return `<div style="display:flex;gap:8px;justify-content:space-between;"><strong>${safeKey}</strong><span>${safeValue}</span></div>`;
                    })
                    .join("");

                popup
                    .setLngLat(e.lngLat)
                    .setHTML(
                        `<div style="min-width:220px;font-size:12px;line-height:1.4;">` +
                            `${rows}` +
                            `<div style="margin-top:8px;font-size:11px;color:#64748b;">` +
                            `Download the full GRAIN data for more attributes` +
                            `</div>` +
                        `</div>`
                    )
                    .addTo(map);
            });

        });

        // 5️⃣ Explicit error handling
        map.on("error", (e) => {
            console.error("MapLibre error:", e);
        });

        map.on("sourcedata", (e) => {
            if (e.sourceId === "grain" && (e.isSourceLoaded || e.loaded)) {
                // sourceLoaded event can be spammy, but useful to confirm
            }
        });

        let baseLineColor = "blue";
        let selectedCountryIso = null;

        const updateGrainLineStyle = () => {
            if (!map.getLayer("grain-lines")) {
                return;
            }

            if (selectedCountryIso) {
                map.setPaintProperty("grain-lines", "line-color", [
                    "match",
                    ["get", "country_iso"],
                    selectedCountryIso,
                    "red",
                    baseLineColor
                ]);
                map.setPaintProperty("grain-lines", "line-width", [
                    "case",
                    ["==", ["get", "country_iso"], selectedCountryIso],
                    ["*", 1.6, baseLineWidthExpr],
                    baseLineWidthExpr
                ]);
            } else {
                map.setPaintProperty("grain-lines", "line-color", baseLineColor);
                map.setPaintProperty("grain-lines", "line-width", baseLineWidthExpr);
            }
        };

        const basemapSelect = document.getElementById("basemap-select");
        basemapSelect.addEventListener("change", () => {
            const selected = basemapSelect.value;
            const isStandard = selected === "standard";
            const isSatellite = selected === "satellite";
            const isNight = selected === "night";

            map.setLayoutProperty("osm", "visibility", isStandard ? "visible" : "none");
            map.setLayoutProperty("esri-imagery", "visibility", isSatellite ? "visible" : "none");
            map.setLayoutProperty("carto-dark", "visibility", isNight ? "visible" : "none");

            baseLineColor = isStandard ? "blue" : isSatellite ? "orange" : "#ffffff";
            updateGrainLineStyle();
        });

        const canalsToggle = document.getElementById("canals-toggle");
        const setCanalsVisibility = () => {
            if (!map.getLayer("grain-lines")) {
                return;
            }
            map.setLayoutProperty(
                "grain-lines",
                "visibility",
                canalsToggle.checked ? "visible" : "none"
            );
        };

        canalsToggle.addEventListener("change", setCanalsVisibility);

        const countrySelect = document.getElementById("country-select");
        let countryFeatures = [];
        const GLOBAL_STATS = {
            length: 3.82,
            density: 200.1,
            cropland: 39.48
        };

        const statLength = document.getElementById("stat-length");
        const statLengthUnit = document.getElementById("stat-length-unit");
        const statCropland = document.getElementById("stat-cropland");
        const statCroplandUnit = document.getElementById("stat-cropland-unit");
        const statDensity = document.getElementById("stat-density");
        const statDensityUnit = document.getElementById("stat-density-unit");

        const formatNumber = (value, options = {}) =>
            new Intl.NumberFormat("en-US", options).format(value);

        const setGlobalStats = () => {
            statLength.textContent = GLOBAL_STATS.length;
            statLengthUnit.textContent = "million km";
            statCropland.textContent = GLOBAL_STATS.cropland;
            statCroplandUnit.innerHTML = "million km<sup>2</sup>";
            statDensity.textContent = GLOBAL_STATS.density;
            statDensityUnit.innerHTML = "km/1000km<sup>2</sup> of cropland";
        };

        const setCountryStats = (properties) => {
            const totalLength =
                (properties?.Agricultural || 0) +
                (properties?.urban_length || 0) +
                (properties?.navigational_length || 0) +
                (properties?.Other || 0);

            statLength.textContent = formatNumber(totalLength, { maximumFractionDigits: 1 });
            statLengthUnit.textContent = "km";

            statCropland.textContent = formatNumber(properties?.cropland_area_km2 || 0, {
                maximumFractionDigits: 0
            });
            statCroplandUnit.innerHTML = "km<sup>2</sup>";

            statDensity.textContent = formatNumber(properties?.canal_density || 0, {
                maximumFractionDigits: 1
            });
            statDensityUnit.innerHTML = "km/1000km<sup>2</sup> of cropland";
        };

        const populateCountries = async () => {
            try {
                const response = await fetch("assets/grain_country_stats.geojson");
                if (!response.ok) {
                    throw new Error(`Failed to load country stats (${response.status})`);
                }
                const data = await response.json();
                countryFeatures = data.features || [];
                const names = Array.from(new Set(
                    countryFeatures
                        .map((feature) => feature?.properties?.name)
                        .filter(Boolean)
                )).sort((a, b) => a.localeCompare(b));

                countrySelect.innerHTML = "";
                const globalOption = document.createElement("option");
                globalOption.value = "global";
                globalOption.textContent = "Global";
                countrySelect.appendChild(globalOption);

                const divider = document.createElement("option");
                divider.disabled = true;
                divider.textContent = "──────────";
                countrySelect.appendChild(divider);

                const fragment = document.createDocumentFragment();
                names.forEach((name) => {
                    const option = document.createElement("option");
                    option.value = name;
                    option.textContent = name;
                    fragment.appendChild(option);
                });
                countrySelect.appendChild(fragment);
            } catch (error) {
                console.error("Failed to populate countries:", error);
            }
        };

        populateCountries();

        countrySelect.addEventListener("change", () => {
            if (countrySelect.value === "global") {
                map.flyTo({ center: [0, 20], zoom: 1 });
                setGlobalStats();
                selectedCountryIso = null;
                updateGrainLineStyle();
                return;
            }

            const selected = countryFeatures.find(
                (feature) => feature?.properties?.name === countrySelect.value
            );
            const point = selected?.properties?.geo_point_2d;
            selectedCountryIso = selected?.properties?.iso3 || null;
            updateGrainLineStyle();
            if (!point || typeof point.lon !== "number" || typeof point.lat !== "number") {
                return;
            }

            setCountryStats(selected?.properties);
            map.flyTo({ center: [point.lon, point.lat], zoom: 5 });
        });
    </script>
</body>

</html>
